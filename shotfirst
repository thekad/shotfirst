#!/usr/bin/env python
import argparse
from datetime import datetime
from gi.repository import GExiv2
from gi.repository import Gio
import hashlib
import logging
import mimetypes
import os
import pyinotify
from Queue import Queue
import shutil
import sys
from traceback import format_exc
from threading import Thread

GSETTINGS = Gio.Settings('org.yorba.shotwell.preferences.files')

DEFAULT_MASK = GSETTINGS.get_string('directory-pattern') or \
       GSETTINGS.get_string('directory-pattern-custom')

DEFAULT_MIME_TYPES = [
    'image/gif',
    'image/jpeg',
]

# Default number of importers
DEFAULT_THREADS = 4


class ConsoleHandler(logging.StreamHandler):
    """A handler that logs to console in the sensible way.

    StreamHandler can log to *one of* sys.stdout or sys.stderr.

    It is more sensible to log to sys.stdout by default with only error
    (logging.ERROR and above) messages going to sys.stderr. This is how
    ConsoleHandler behaves.
    """

    def __init__(self):
        logging.StreamHandler.__init__(self)
        self.stream = None # reset it; we are not going to use it anyway

    def emit(self, record):
        if record.levelno >= logging.ERROR:
            self.__emit(record, sys.stderr)
        else:
            self.__emit(record, sys.stdout)

    def __emit(self, record, strm):
        self.stream = strm
        logging.StreamHandler.emit(self, record)

    def flush(self):
        # Workaround a bug in logging module
        # See:
        #   http://bugs.python.org/issue6333
        if self.stream and hasattr(self.stream, 'flush') and not self.stream.closed:
            logging.StreamHandler.flush(self)


LOGGER = logging.getLogger('shotfirst')
LOGGER.setLevel(logging.DEBUG)
handler = ConsoleHandler()
if os.environ.get('SDEBUG', False):
    handler.setLevel(logging.DEBUG)
else:
    handler.setLevel(logging.INFO)
format = '%(asctime)s %(levelname)s %(name)s %(message)s'
formatter = logging.Formatter(format)
handler.setFormatter(formatter)
LOGGER.addHandler(handler)


class ImportHandler(pyinotify.ProcessEvent):
    def my_init(self, threads=DEFAULT_THREADS, target_dir=None,
                log=LOGGER, watch_dirs=[], operation='move',
                mime_types=DEFAULT_MIME_TYPES, prune=False,
                mask=DEFAULT_MASK):

        self.target = target_dir
        self.log = log
        self.fileq = Queue()
        self.mime_types = mime_types
        self.prune = prune
        self.op = getattr(shutil, operation)

        for i in range(int(threads)):
            t = Thread(target=self.worker)
            t.daemon = True
            t.start()

    def worker(self):
        while True:
            f = self.fileq.get()
            try:
                self.import_image(f)
            except:
                self.log.error('Failed importing %s.\n%s' %
                               (f, format_exc()))

            self.fileq.task_done()

    def process_IN_CLOSE_WRITE(self, event):
        self.add_file(event.pathname)

    def process_IN_MOVED_TO(self, event):
        self.add_file(event.pathname)

    def get_datetime(self, fullpath):
        exif = GExiv2.Metadata()
        exif.open_path(fullpath)
        dtime = None
        try:
            dtime = exif.get_date_time()
            self.log.debug('Timestamp string is %s' % (dtime,))
            dtime = datetime.strptime(dtime, '%Y:%m:%d %H:%M:%S')
        except:
            self.log.error('Could not fetch timestamp for %s, skipping' % (
                           fullpath))
            return False
        self.log.debug('Timestamp for %s is %s' % (
                       os.path.basename(fullpath), dtime,))
        return dtime

    def add_file(self, fullpath):
        self.log.debug('Analyzing %s for inclusion...' % (fullpath,))
        try:
            (f_type, f_encoding) = mimetypes.guess_type(fullpath)
            self.log.debug('%s is %s' % (fullpath, f_type,))
            if f_type in self.mime_types:
                self.log.info('Will import %s (via %s)' % (
                              fullpath, self.op.__name__))
                self.fileq.put(fullpath)
        except:
            self.log.debug('Could not guess mime type for %s!' % (fullpath,))
            return

    def import_image(self, orig_file):
        dtime = self.get_datetime(orig_file)
        if not dtime:
            return False
        fname = os.path.basename(orig_file).lower()
        fsubdir = '%s/%s' % (self.target, dtime.strftime('%Y/%m/%d'),)
        dest_file = '%s/%s' % (fsubdir, fname)
        if os.path.exists(dest_file):
            self.log.debug('Destination file %s already exists, comparing' % (
                           dest_file,))
            dest_md5 = hashlib.md5(open(dest_file).read()).hexdigest()
            orig_md5 = hashlib.md5(open(orig_file).read()).hexdigest()
            self.log.debug('%s == %s ? %s' % (dest_md5, orig_md5,
                           dest_md5 == orig_md5))
            if dest_md5 == orig_md5:
                if self.prune:
                    self.log.warn('File already exists, deleting file being '
                                  'imported to avoid this problem in the '
                                  'future')
                    os.unlink(orig_file)
                else:
                    self.log.warn('File %s already exists' % (dest_file,))
                return
            else:
                self.log.warn('A file with the same name (%s) exists, but '
                              'it seems different. Will leave them alone' % (
                              os.path.basename(dest_file)))
                return

        if not os.path.isdir(fsubdir):
            os.makedirs(fsubdir)
        self.op(orig_file, dest_file)
        self.log.info('Imported %s -> %s' % (orig_file, dest_file,))


def import_file(handler, filename, filedir, log):
    if not filedir.endswith('/'):
        filedir += '/'

    fullpath = os.path.abspath('%s%s' % (filedir, filename))

    if os.path.isdir(fullpath):
        return

    handler.add_file(fullpath)


def get_mask(listen_events=['IN_MOVED_TO', 'IN_CLOSE_WRITE']):
    mask = 0
    while listen_events:
        mask = mask | getattr(pyinotify, listen_events.pop())

    return mask


def import_files(handler, paths, recurse, log=LOGGER):
    for path in paths:
        log.info('Import from %s' % path)
        if recurse:
            for root, dirs, files in os.walk(path):
                for filename in files:
                    import_file(handler, filename, root, log)
        else:
            for filename in os.listdir(path):
                import_file(handler, filename, path, log)
    return 0


def main():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description='Tablesnap is a script that')
    parser.add_argument('--target', help='Destination folder', required=True,
                        default=GSETTINGS.get_string('import-dir'))
    parser.add_argument('--import-mask', help='Target import mask',
                        default=DEFAULT_MASK)
    parser.add_argument('paths', metavar='path', nargs='+',
                        help='Paths to be watched')
    parser.add_argument('--threads', default=DEFAULT_THREADS,
                        help='Default number of worker threads to create')
    parser.add_argument('--no-auto-add', action='store_true', default=False,
                        help='Do not automatically watch sub-directories')
    parser.add_argument('--no-recurse', action='store_true', default=False,
                        help='Do not recurse')
    parser.add_argument('--prune', action='store_true', default=False,
                        help='Prune duplicated files from source(s)')
    parser.add_argument('--copy', action='store_const', dest='operation',
                        default='move', const='copy',
                        help='Copy files instead of moving them.')
    args = parser.parse_args()

    LOGGER.info('Starting up')


    handler = ImportHandler(threads=args.threads, watch_dirs=args.paths,
                            target_dir=args.target, prune=args.prune,
                            operation=args.operation, mask=args.import_mask)

    wm = pyinotify.WatchManager()
    notifier = pyinotify.Notifier(wm, handler)

    mask = get_mask()
    for path in args.paths:
        ret = wm.add_watch(path, mask, rec=not args.no_recurse,
                           auto_add=not args.no_auto_add)
        if ret[path] == -1:
            LOGGER.critical('add_watch failed for %s, bailing out!' %
                                (path))
            return 1

    import_files(handler, args.paths, not args.no_recurse)

    notifier.loop()

if __name__ == '__main__':
    sys.exit(main())
